{"./":{"url":"./","title":"简介","keywords":"","body":"简介 这是我在学习Spring Boot的笔记。欢迎大家和我一起完善。 本笔记很大程度上参考了《Spring Boot2 精髓》李家智，但是不得不说，这本书写的质量真的很差，书中1/3的篇幅用来介绍作者自己写的工具的使用上面，对于更好的更通用的工具不做介绍。所以很多和这本书作者的王婆卖瓜的文章没有做任何笔记，相对的使用功能类似的更好的工具替换。 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-12 00:04:37 "},"chapter1/":{"url":"chapter1/","title":"第一章","keywords":"","body":"Spring 介绍 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-11 20:35:26 "},"chapter1/Spring.html":{"url":"chapter1/Spring.html","title":"第1节：Spring","keywords":"","body":"Spring 建议啥都不要管，照着这个教程来，先让一个Spring Boot跑起来，更有动力学习！ 或者这个大佬 IoC（控制反转）管理Bean, AOP（面向切面）方式增强Bean功能 Spring IoC容器和AOP IoC Core Container：负责管理对象，通过对象描述对对象初始化以及加强。 例如： @Controller：对象变为Web Controller, 用来负责处理Web请求，@RequestMapping：请求路径匹配，被注解的方法被调用。 @Controller public class HelloworldController { @RequestMapping(\"/sayhello.html\") public @ResponseBody String say(String name) { return \"hello\" +name; } } AOP：通过预编译方式或者运行时刻对目标动态的添加功能。比如要实现用户访问控制，可以对每个Controller 的方法使用一个自定义的注解Function ，用SpringA OP向Controller 每个方法动态地添加用户权限校验功能，类似如下： @RequestMapping(\"/sayhello.html\") public @ResponseBody String say (String name) { return \"hello\" +name ; } @RequestMapping(\"/adduser.html\") @Function(\"user.add\") public @ResponseBody String addUser (String name) { ...... } 此处是个举例，不用理解。 @Configuration // 注解成功引起Sping Container注意 @Aspect // 声明为AOP类 public class RoleAccessConfig { @Around(\"within(@org.springframework.stereotype.Controller * ) && @annotation(function)\") public Object functionAccessCheck(final ProceedingJoinPoint pjp, Function function) throws Throwable { if (function ! =null ) { String functionName = function.value(); if(!canAccess(functionName)) { MethodSignature ms= (MethodSignature) pjp.getSignature(); throw new RuntimeException(\"Can not Acces s\" + ms.getMethod()); } } // 继续处理原有的调用 Object o = pjp.proceed(); return o; } protected boolean canAccess(String functionName) { if(functionName.length()==0) { // 总是允许访问 return true; }else{ // 取出当前用户对应的所有角色，从数据库中查询角色是否有访问functionName的权限 return false; } } } Spring的缺点 使用门槛升高， 要入门Spring 需要较长时间。 对过时技术兼容， 导致使用复杂度升高。 XML 配置已经不是流行的系统配置方式。 集成第三方工具时候，程序员还要考虑工具之间的兼容性。 系统启动慢，不具备热部署功能，完全依赖虚拟机或者Web 服务器的热部 1和4在Spring Boot中被解决 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-13 11:41:24 "},"chapter1/SpringBoot.html":{"url":"chapter1/SpringBoot.html","title":"第2节：Spring Boot","keywords":"","body":"Spring Boot 系统级服务 Spring Boot通过Starter提供系统级服务，下表是Spring Boot提供的Starter： 名称 作用 spring-boot-starter-web Web开发支持， 默认使用Tomcat8 spring-boot-starter-aop AOP 开发支持，使用AspectJ spring-boot-starter-jdbc Spring JDBC spring-boot-starter-data-jpa JPA 方式访问数据库，使用Hibernate 作为JPA 实现 spring-boot-starter-data-elasticsearch 集成Elasticsearch ，默认访问localhost:9200 spring-boot-starter-data-redis 集成Redis ，使用JRedis ，默认连接localhost:6379 spring-boot-starter-cache 缓存， 支持多种缓存方式，如本地的、Redis 、Ehcache 等 spring-boot-devtools 应用程序快速重启的工具，提升开发体验 spring-boot-starter-data-mongodb 集成MongoDB ，默认访问mongodb://localhost/test spring-boot-starter-data-neo4j 集成neo4j ， 默认访问localhost:7474 spring-boot-starter-data-gemfire 集成分布式缓存 spring-boot-starter-data-soIr 基于Apache lucene的搜索平台，默认访问localhost:8983/solr spring-boot-starter-data-cassandra 集成Cassandra，默认访问localhost:7474 spring-boot-stater-data-ldap 集成ldap spring-boot-starter-activemq 消息集成ActiveMQ 支持 spring-boot-starter-amqp 消息集成AMQP 协议支持，如支持RabbitMQ spring-boot-starter-jta-atomikos 分布式事务支持，使用atomikos spring-boot-stater-jta-bitronix 一个开源的分布式事务支持 spring-boot-starter-test 包含JUnit 、Spring Test、Hamcrest 、Mockito 等测试工具 spring-boot-starter-webservices webservice 支持 spring-boot-starter-websocket websocket 支持 spring-boot-starter-jersey REST 应用和Jersey 支持 spring-boot-starter-freemarker Freemaker 支持 优点 实现约定大于配置，是一个低配置的应用系统框架。不像Spring 那样“地狱般的配置体验”， Spring Boot 不需要配置或者极少配置，就能使用Spring 大量的功能。 提供了内置的Tomcat 或者Jetty 容器。 通过依赖的jar 包管理、自动装配技术，容易支持与其他技术体系、工具集成。 支持热加载，开发体验好。也支持Spring Boot 系统监控，方便了解系统运行状况。 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-10 01:27:46 "},"chapter1/HelloWorld.html":{"url":"chapter1/HelloWorld.html","title":"第3节：Hello World","keywords":"","body":"Hello World 教程基于IntelliJ 打开IntelliJ IDEA，选择新建项目 选择Spring Initializer，此处用Default（Spring官网），点击下一步，然后输入Group以及Artifact等，其他的保持不变（可以选择一下Java Version）。 然后编写一个Controller类, 放在Controller目录下面 其中UserController的代码为： package top.cofal.guardianship.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; @RestController @EnableAutoConfiguration public class UserController { @RequestMapping(value = \"/\") public String hello(HttpServletRequest request, HttpServletResponse response) { return \"Hello World!\"; } } 点击右上角的运行，就可以在浏览器的http://localhost:8080/，国内的Maven速度可能很慢，所以建议在运行钱更换国内镜像！ 开启热更新，方便调试，修改pom.xml： org.springframework.boot spring-boot-devtools true org.springframework.boot spring-boot-maven-plugin true 设置IntelliJ 设置中开启自动编译 Ctrl+Shift+Alt+/选择Registry，设置compiler.automake.allow.when.app.running为勾选。 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-10 23:03:45 "},"chapter1/SpringAOP.html":{"url":"chapter1/SpringAOP.html","title":"第4节：Spring AOP","keywords":"","body":"Spring AOP Aspect-Oriented Programming，面向切面编程 应用可以在运行时刻动态地在方法调用前后“织入”一些公共代码，从而提供系统的公共服务。类似Python3中的函数修饰符。 AOP 有如下术语： Aspect：Aspect 声明类似于Java 中的类声明，在Aspect 中会包含一些Pointcut 及相应的Advice。 Joint point ： 表示在程序中明确定义的点，典型的包括方法调用、对类成员的访问， 以及异常处理程序块的执行等。Spring 中的Joint point 只支持方法调用。 Pointcut ： 表示一组Joint point ， 如方法名、参数类型、返回类型等，这些Joint point 通过逻辑关系组合起来， 它定义了相应的Advice 将要发生的地方。简单理解Pointcut（ 一种表达式）一一用来判断在Joint point （方法调用）中执行Advice （操作）。 Advice：Advice 定义了在Pointcut 里面定义的程序点具体要做的操作， 它通过before 、around 、after ( return 、throw 、finally ）来区别是在每个Joint point 之前、之后还是执行前后要调用的代码。 before ： 在执行方法前调用Advice ，比如cache 功能可以在执行方法前先判断是否有缓存。 around ： 在执行方法前后调用Advice ， 这是Spring 框架和应用系统一种最为常用的方法， 参见第一章Spring。 after ： 在执行方法后调用Advice, after return 是方法正常返回后调用， after throw是方法抛出异常后调用。 finally ： 方法调用后执行Advice ， 无论是否抛出异常还是正常返回。 AOP proxy：AOP Proxy 也是Java 对象，由AOP 框架创建， 用来完成上述的动作， AOP对象通常可以通过JDK dyamic proxy 完成，或者使用CGLib 完成。 Weaving ： 实现上述切面编程的代码织入， 可以在编译时刻（通过AspectJ compiler ) ，也可以在运行时刻， Spring 和其他大多数Java 框架都是在运行时刻生成代理。 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-10 14:02:47 "},"chapter2/":{"url":"chapter2/","title":"第二章","keywords":"","body":"MVC入门 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-11 20:35:55 "},"chapter2/MVC.html":{"url":"chapter2/MVC.html","title":"第1节：MVC","keywords":"","body":"MVC 首先是目录结构： Web 的模板文件位于resources/templates 目录下，模板文件使用的静态资源文件，如JS 、 css 、图片，存放在resources/static 目录下。 @RequestMapping和@Controller 参见附录/注解符 方法参数 @PathVariable，可以将URL 中的值映射到方法参数中。可以是类前和方法先的路径匹配，自动对应同名参数，不同名可以用@PathVariable(\"id\")来对应不同名的参数。 Model，Spring 中通用的MVC 模型，也可以使用Map 和ModelMap 作为渲染视图的模型。 在方法的参数中使用如下： @GetMapping(path = \"/{userid}/get.html\") public String getUser(@PathVariable Long userid, Model model) { User userInfo = userService.getUserById(userid); // model.addAttribute(userinfo) 与下面代码效果相同 // 但是这个方法声明会在之后的代码重构中出现错误，建议使用下面一种 model.addAttribute(\"user\", userinfo); return \"/userinfo.html\"; } 在模板中使用模型中的数据如下： ${user.id}${user.name} Model addAttribute(String attributeName, Object attributeValue)，向模型添加一个变量，attributeName 指明了变量的名称，可以在随后的视图里引用， attributeValue 代表了变量。 Model addAttribute (Object attributeValue)， 向模型添加一个变量，变量的名字就是其类名字首字母小写后转为的Java 变量。 Model addAllAttributes(Map attributes)，添加多个变量，如果变量已经存在，则覆盖。 Model mergeAttributes(Map attributes)，添加多个变量， 如果变量己经存在于模型中，则忽略。 Model addAllAttributes(Collection attributeValues)， 添加多个变量，变量来自于集合的元素， 变量命名规范同时addAttribute(Object attributeValue) 。 boolean containsAttribute(String attributeName)， 判断是否存在变量。 ModelAndView，包含了模型和视图路径的对象。 @GetMapping(path = \"/{ userid}/get2.html\") public ModelAndView getUser2(@PathVariable Long userid, ModelAndView view) { // 也可以如下声明： // public ModelAndView getUser2(@PathVariable Long userid) { // ModelAndView view = new ModelAndView(); User userinfo = userService.getUserById (userid); view.addObject(\"user\",userinfo); view.setViewName(\"/userinfo.html\"); return view; } JavaBean，将HTTP 参数映射到JavaBean 对象。 public String getUser2(@RequestParam(value=\"id\", required=true, defaultValue=\"\") Integer id, String name) 其中复杂的映射如下： 订单名称： 订单明细1： 订单明细2： // 模型代码 public class OrderPostForm { private Order order; private List details; // 忽略getter和setter } // Controller代码 @PostMapping(path=\"./saveorder.json\") @ResponseBody public String saveOrder(OrderPostForm form) { return \"Success\"; } spring.servlet.multipart.enabled=true # 设定上传的文件超过一定长度之后写道零时文件中，0则没有阈值 spring.servlet.multipart.file-size-threshold=0 # 零时文件存放目录，不设定则由Web服务器提供 spring.servlet.multipart.location= # 单个文件的最大尺寸 spring.servlet.multipart.max-file-size=1MB # 单次请求的最大尺寸 spring.servlet.multipart.max-request-size=10MB # 当文件和参数被访问的时候再解析为文件 spring.servlet.multipart.resolve-lazily=false 其中回自动将html中的name属性对应到模型中对应的属性，例如order.name对应order属性的name属性，方括号对应List对应位置的元素。一定要是List不可以是Set。 MultipartFile，用于处理文件上传。 提供的对文件信息获取的方法： getPriginalFilename，获取上传文件的民字； getBytes，获取上传文件内容，转为字节数组； getInputStream，获取一个InputStream； isEmpty，文件上传内容为空，或者没有文件上传； getSize，文件上传的大小； transferTo(File dest)，保存上传文件到目标文件系统； @PostMapping(\"/form\") @ResponseBody public String handleFormUpload(String name, MultipartFile[] files) throws IOException { return \"Success\"; } 对应的html中有多个名为files的文件 选择文件： 选择文件： 选择文件： @ModeIAtribute，使用该注解的变量将作为Model 的一个属性。 @ModelAttribute public void findUserByid(@PathVariable Long id, Model model) { model.addAttribute(\"user\", userService.getUserByid(id)); } // 如果需要注入的属性只有一个等同下面的写法 @ModelAttribute public void findUserByid(@PathVariable Long id) { return userService.getUserByid(id); } @GetMapping(path = \"/{id)/get.json\") @ResponseBody public String getUser(Model model) { System.out.println(model.containsAttribute(\"user\")); return \"success\"; } WebRequest或者NativeWebRequest，类似Servlet Request ，但做了一定封装。 java.io.InputStream 和java.io.Reader，用来获取Servlet API 中的lnputStream/Reader 。 java.io.OutputStream 和java.io.Writer，用来获取Servlet API 中的OutputStream/Writer 。 HttpMethod， 枚举类型， 对应于HTTP Method ，如POST 、GET。 @MatrixVariable，矩阵变量。 @RequestParam， 对应于HTTP 请求的参数，自动转化为参数对应的类型。 @RequestHeader，对应于HTTP 请求头参数，自动转化为对应的类型。 @RequestBody， 自动将请求内容转为指定的对象， 默认使用HttpMessageConverters来转化。同时也说明HTTP的消息体是一个JSON，转化为指定的对象。 @PostMapping(path=\"/savejsonorder.json\") @ResponseBody public String saveOrderByJson(@RequestBody User user) { return user.getName(); } @RequestPart，用于文件上传，对应于HTTP 协议的multipart/form-data 。 @SessionAttribute， 该方法标注的变量来自于Session 的属性。 @RequestAttribute，该标注的变量来自于request 的属性。 @InitBinder，用在方法上，说明这个方法会注册多个转化器，用来个性化地将HTTP请求参数转化成对应的Java 对象，如转化为日期类型、浮点类型、JavaBean 等，当然，也可以实现WebBindinglnitializer 接口来用于Spring Boot 应用所需要的dataBinder 。 @Controller public class MyFormController { @InitBinder protected void initBinder(WebDataBinder binder) { binder.addCustomFormatter(new DateFormatter(\"yyyy-MM-dd\")); } @ResponseBody @RequestMapping(\"/date\") // databind/date?d=2011-1-1 public void printDate(Date d) { System.out.println(d); return; } } BindingResult 和Errors， 用来处理绑定过程中的错误。 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-11 09:42:09 "},"chapter2/validation.html":{"url":"chapter2/validation.html","title":"第2节：验证框架","keywords":"","body":"验证框架 JSR-303 提供一系列注解来验证Bean的属性，实现有Hibernate validator 定义的注解 空检查 @Null，验证对象是否为空 @NotNull，验证对象不为空 @NotBlank，验证字符串不为空或不为空字符串、空白字符串 @NotEmpty，验证对象不为null，或者集合不为空 长度检查 @Size(min=, max=)，验证对象长度，可以是字符串或者是集合 @Length，字符串大小 数值检测 @Min，验证数字是否大于等于指定的值 @Max，验证数字是否小于等于指定的值 @Digits，验证数字是否符合指定格式，如@Digits(integer=9, fraction=2) @Range，验证数字是否在指定范围内，如@Range(min=1, max=1000) 其他 @Email，验证是否为邮件格式，null则不校验 @Pattern，验证String是否符合正则表达式 public class WordInfoForm { @NotNull Long id; @Size(min=3, max=20) String name; @Email String email; } Group 可以对每个注解指定一个或多个group，当Spring Boot 校验对象的时候，也可以指定校验的上下文属于哪个group 。这样， 只有group 匹配的时候，校验注解才能生效。上面的WorklnfoForm 定义id 字段校验可以更改为如下内容： public class WorkInfoForm { // 定义一个类，更新时校验组 public interface Update{}; // 定义一个类，添加时校验组 public interface Add{}; @NotNull(groups={Update.class}) @Null(group={Add.class}) Long id; } 表示当校验上下文为Add.class的时候，@Null生效，id为空才能通过校验；当上下文为Update.class的时候，@NotNull生效，id不能为空。 MVC中使用@Validated 示例： @ResponseBody @RequestMapping(\"/addworkinfo.html\") public void addWorkInfo(@Validated({WorkInfoForm.Add.class}) WordInfoForm workInfo, BindingResult result) { if (result.hasErrors()) { List list = result.getAllErrors(); FieldError error = (FieldError)list.get(0); System.out.println(error.getObjectName+\",\"+error.getField()+\",\"+error.getDefaultMessage()); return; } return; } 其中HTTP参数映射到WorkInfoForm对象，由于@Validated注解，触发Spring的校验，并且验证结果存放到BindingResult对象中。这里校验使用WordInfoForm.Add.class，所以校验按照Add.class执行。如果没有BindingResult则抛出异常。 前后端校验可以并行： 前端校验可以减少前端和后端的通信，将简单的校验在前端完成 后端校验可以防止用户绕过前端校验 自定义校验 import javax.validation.ConstraintValidator; import javax.validation.ConstraintValidatorContext; public class WorkOverTimeValidator implements ConstraintValidator { WorkOverTime work; int max; public void initialize(WorkOverTime work) { // 获取注解的定义 this.work = work; max = work.max(); } public boolean isValid(Integer value, ConstraintValidatorContext context) { if (value == null) { return true; } return value [] groups() default {}; // 验证的有效负荷,必须包含 Class[] payload() default {}; } Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-11 11:24:07 "},"chapter2/WebMvcConfigurer.html":{"url":"chapter2/WebMvcConfigurer.html","title":"第3节：WebMvcConfigurer","keywords":"","body":"WebMvcConfigurer 全局定值化Spring Boot的MVC特性。开发者通过实现WebMvcConfigurer接口来配置全局特性。 class SessionHandlerInterceptor implements HandlerInterceptor { // 在Controller方法前会调用此方法 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { User user = (User)request.getSession().getAttribute(\"user\"); if (user == null) { // 没有登录则重定向到login response.sendRedirect(\"/login\"); return false; } return true; } // 在Controller方法调用之后，页面渲染前调用，可以在此处将渲染的视图名称改为其他视图 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { // Controller 处理完毕调用此方法 } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // 页面渲染完毕后调用此方法，通常用来清除某些资源 } } // 实现WebMvcConfigurer @Configuration public class MvcConfigurer implements WebMvcConfigurer { // 拦截器 public void addInterceptors(InterceptorRegistry registry) { // 对特点URI访问设定拦截器，检查用户登录或者处理请求的时间 registry.addInterceptor(new SessionHandlerInterceptor()).addPathPatterns(\"/admin/**\"); } // 跨域访问配置 public void addCorsMappings(CorsRegistry registry) { // 设定Access-Control-Allow-Origin registry.addMapping(\"api/**\") .allowedOrigins(\"http://example.com\") .allowedMethods(\"POST\", \"GET\"); } // 格式化 public void addFormatters(FormatterRegistry registry) { resgistry.addFormatter(new DateFormatter(\"yyyy-MM-dd HH:mm:ss\")); } // URI到视图的映射 public void addViewControllers(ViewControllerRegistry registry) { // 对于简单的过程没必要定义一个Controller可以直接在此处设定视图 registry.addViewController(\"index.html\").setViewName(\"/index.btl\"); // 将所有的.do结尾的请求重定向到/index.html registry.addRedirectViewController(\"/**/*/do\", \"/index.html\"); } } Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-11 14:06:42 "},"chapter2/view.html":{"url":"chapter2/view.html","title":"第4节：视图技术","keywords":"","body":"视图技术 Spring Boot支持的视图技术： FreeMarker Groovy Thymeleaf Mustache FreeMarker Jackson Jackson 是一个流行的高性能JavaBean 到JSON 的绑定工具， Jackson 使用ObjectMapper 类将POJO 对象序列化成JSON 字符串， 也能将JSON 字符串反序列化成POJO 对象。实际上，Jackson 支持三种层次的序列化和反序列化方式。 采用JsonParser 来解析JSON ，解析结果是一串Tokens ，采用JsonGenerator 来生成JSON ，这是最底层的方式。 采用树遍历（Tree Traversing ）方式， JSON 被读入到JsonNode 对象中，可以像操作XML DOM 那样读取JSON 。 采用DataBind 方式，将POJO 序列化成JSON ，或者反序列化到POJO ，这是最直接和最简单的一种方式，不过有时候需要辅助Jackson 的注解或者上述序列化实现类来个性化序列化和反序列化操作。 关于POJO以及JavaBean之间的区别和关系：大佬博文 @ResponseBody会将返回的对象序列化，默认使用Spring Boot 内置Jackson完成Jackson的序列化和反序列化。 @Configuration public class JacksonConf { // 配置后则会使用这个自定义的Jackson序列化来返回@ResponseBody @Bean public ObjectMapper getObjectMapper() { ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")); return objectMapper; } } Jackson树遍历 @Autowired ObjectMapper mapper; @GetMapping(\"/read.json\") public @ResponseBody String read() throws JsonProcessingException, IOException { String json = \"{\\\"name\\\":\\\"cofalconer\\\"}\"; JsonNode node = mapper.readTree(json); String name = node.get(\"name\").asText(); return \"name:\"+name; } 对象绑定 public class User { // set和get方法也需要 Long id; String name; } @GetMapping(\"/data.json\") public @ResponseBody String data() throws JsonProcessingException, IOException { String json = \"{\\\"name\\\":\\\"cofalconer\\\",\\\"id\\\":10}\"; User user = mapper.readValue(json, User.class); // String json2 = mapper.writeValueAsString(user); return \"name:\"+user.getName(); } Jackson注解 @JsonProperty，作用在属性上，用来指定一个别名@JsonProperty(\"userName\") @JsonIgnore，作用在属性上，忽略这个属性 @JsonIgnoreProperties，作用在类上，忽略一组属性，例如@JsonIgnoreProperties({\"id\", \"photo\"}) @JsonAnySetter，作用在方法上，在序列化过程中没有对应属性的都调用这个方法。 @JsonAnySetter private void other(String property, Object value) { map.put(property, value); } @JsonAnyGetter，作用在返回值为Map的方法上，Jackson会取出Map中的每一个值进行序列化 // 序列化结果：{\"id\": 1, \"newAttr\": 1} class Department { Map map= new HashMap(); int id; public Department(int id) { this.id = id; map.put(\"newAttr\", 1); } @JsonAnyGetter public Map getOtherProperties() { return map; } } @JsonFormat，用于日期格式化 @JsonFormat(pattern = \"yyyy-MM-dd HH-mm-ss\") private Date createDate; @JsonNaming，用于指定一个命名策略，作用于类或者属性上，类似＠JsonProperty ，但是自动命名。Jackson 自带了多种命名策略，你可以实现自己的命名策略，比如输出的key 由Java命名方式转为下面线命名方法一一userName 转化为user_name 。 @JsonNaming(PropertyNamingStrategy.LowerCaseWithUnderscoresStrategy.class) public class Message {} @JsonSerialize，指定一个实现类来自定义序列化。类必须实现JsonSerializer 接口，代码如下： public static class Usererializer extends JsonSerializer { @Override public void serialize(User value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException { jgen.writeStartObject(); jgen.writeStringField(\"user_name\", value.getName()); jgen.writeEndObject(); } } @JsonSerialize(using = Usererializer.class) public class User { // ... } @JsonDeserialize，自定义反序列化，需要实现JsonDeserializer public class UserDeserializer extends JsonDeserializer { @Override public User deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException , JsonProcessingException { JsonNode node = jp.getCodec().readTree(jp); String name = node.get(\"user_name\").asText(); User user = new User(); user.setName(name); return user; } } @JsonDeserializer(using = UserDeserializer.class) public class User { // ... } @JsonView，作用在类或者属性上，用来定义一个序列化组。Spring MVC 的Controller 方法可以使用同样的＠JsonView 来序列化属于这一组的配置。 public class User { public interface IdView {}; public interface IdNameView extends IdView {}; @JsonView(IdView.class) private Integer id; @JsonView(IdNameView.class) private String name; // // set和get方法也需要 } // 属于User.IdView，所以序列化结果为{\"id\": 1} @JsonView(User.IdView.class) @RequestMapping(\"/id.json\") public @ResponseBody User queryIds () { User user= new User(); user.setld(1); user.setName(\"hell\"); return user; } 更多用法参考：官网 复杂的反序列化 如果请求是一个User列表的JSON，可能因为属性名位置不对导致反序列化失败。 // 失败的反序列化 @RequestMapping(\"/customize.json\") public @ResponseBody String customize() throws Exception{ String jsonInput =\"[{\\\"id\\\": 2, \\\"name\\\": \\\"cofalconer\\\"}, {\\\"id\\\": 3,\\\"name\\\":\\\"lucy\\\"}]\"; //错误的序列化 List list = mapper.readValue(jsoninput, List.class); return String.valueOf(list.size()); } // 为了提供泛型信息，Jackson提供了JavaType ，用来指明集合类型，比如应用可以提供一个通用getCollectionType public JavaType getCollectionType(Class collectionClass, Class...elementClasses) { // 更为复杂的类型 // List：使用constructParametricType(List.class, Set.class, User.class) // Map：使用constructParametricType(Map.class, String.class, User.class) return mapper.getTypeFactory().constructParametricType(collectionClass, elementClasses); } // 更换为这个语句反序列化即可 JavaType type = getCollectionType(List.class, User.class); List list = mapper.readValue(jsoninput, type); Redirect和Forward Controller中重定向可以返回以“redirect:\"为前缀的URI，还可以使用forward前缀。 @RequestMapping(\"/order/save\") public String saveOrder() { Loginh orderId = service.addOrder(order); return \"redirect:/order/detail.html?orderId=\"+orderId; // ModelAndView view = new ModelAndView(\"redirect:/order/detail.html?orderId=\"+orderId); // RedirectView view = new RedirectView(\"/order/detail.html?orderId=\"+orderId); } JsonNode 支持以下方法来读取JSON数据： asXXX，比如asText 、asBoolean、aslnt 等，读取JsonNode 对应的值。 isArray， 用于判断JsonNode 是否是数组，如果是数组，则可以调用get(i） 来进行遍历，通过size() 来获取长度。 get(String)，获取当前节点的子节点，返回JsonNode ， 如以上代码所示。 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-11 23:56:43 "},"chapter2/error.html":{"url":"chapter2/error.html","title":"第5节：错误处理","keywords":"","body":"错误处理 Spring Boot的Controller中抛出的异常默认交给/error来处理，可以将/error映射到特定的Controller中，需要继承AbstractErrorController。 @Controller public class ErrorController extends AbstractErrorController { Log log = LogFactory.getLog(ErrorController.class); @Autowired ObjectMapper objectMapper; public ErrorController() { super(new DefaultErrorAttributes()); } // @RequestMapping(\"/error\") @RequestMapping(ERROR_PATH) public ModelAndView getErrorPath(HttpServletRequest request, HttpServletResponse response) { // 异常处理 // getErrorAttributes由AbstractErrorController提供用于获取错误消息 Map model = Collections.unmodifiableMap(getErrorAttributes(request, false)); // 获取异常，可能为空 // 获取应用系统的异常 Throwable cause = getCause(request); int status = (Integer)model.get(\"status\"); // 错误详细 String message = (String)model.get(\"messgae\"); // 友好提示，自定义 String errormessage = getErrorMessage(cause); // 后台打印日志方便差错 log.info(status+\",\"+message, cause); response.setStatus(status); // isJsonRequest自定义 if (!isJsonRequest(request)) { // error.btl 模板显示错误的详细信息 ModelAndView view= new ModelAndView(\"/error.btl\"); view.addAllObjects(model); view.addObject(\"errorMessage\", errorMessage); view.addObject(\"status\", satus); view.addObject(\"cause\", cause); return view; )else{ Map error= new HashMap(); error.put(\"success\", false); error.put(\"errorMessage\", errorMessage); error.put(\"message\", message); writeJson(response , error); return null ; } } } AbstractErrorController提供了多个方法从request中获取错误信息，其中错误消息包含： timestamp，错误发生时间 status，HTTP Status error，错误消息，如Bad Request message，详细错误详细 exception，如果抛出异常，exception为异常的类名 path，请求URI errors，@Validated的校验报错 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-11 20:25:22 "},"chapter2/transactional.html":{"url":"chapter2/transactional.html","title":"第6节：服务与事务","keywords":"","body":"@Service & @Transactional Controller的调用业务逻辑处理交给了被@Service注解的类，是个普通的JavaBean，Controller中可以自动注入这种Bean，并且调用其方法完成业务逻辑，通常搭配@Transactional。 声明@Service 文件结构如下，domain中放模型，service中放Service接口，service.impl中放接口的实现 ├─java │ └─com.example.project │ ├─controller │ │ └─rest │ ├─domain │ ├─mapper │ └─service │ └─impl └─resources ├─mapperXml ├─static └─templates └─user 先定义一个UserService的接口。 package com.example.project.service; public interface UserService { public User getUserById(Long id); public void updateUser(Long id, Integer type); } 然后实现此业务接口，使用@Service注册服务，同时搭配@Transactional进行事务增强。 package com.example.project.service.impl; import com.example.project.service.UserService; @Service @Transactional public class UserServiceImpl implements UserService { public User getUserById(Long id) { return user; } public void updateUser(Long id, Integer type) { return; } } Spring Boot没有要求Service必须实现某个接口，但是一般还是为Service定义接口，这样允许为这个Service提供不同的实现，比如模拟业务实现，单元测试中通过Mock来模拟一个Service实现。 @Transaction org.springframework.boot spring-boot-starter-jdbc @Transactional可以作用在类上，这样所有的接口方法都会参与事务管理，也可以放到方法上，则只有方法参与。 当Controller 调用Service 方法的时候，会开启一个事务上下文，随后的调用都将处于这个事务上下文中。如果调用这个Service 方法抛出RuntimeException， 事务会自动回滚。否则，事务将提交。 事务上下文： 对于Service 调用，如果处于同一个事务上下文，那么对数据库的操作会在一个事务中。事务上下文的开启是从Controller中调用Service 方法的时候自动开启的，并在调用此方法后自动结束从而提交事务，或者根据抛出的RuntimeException 来自动回滚，调用过程中调用的其他Service 方法都会处于这个事务上下文中。 可以在事务上下文中再次开启一个新的事务上下文，这时候通过注解＠Transactional(propagation = Propagation.REQUIRES_NEW) 完成，比如在AuditService 中，审计服务无论业务调用是否成功，都必须把审计信息存储到数据库中，因此AuditService 可以配置为开启新的事务上下文。 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-11 21:13:19 "},"chapter3/":{"url":"chapter3/","title":"第三章","keywords":"","body":"数据相关 首先可以看看我参考的博文，大佬就是大佬啊！ 还有MyBatis官网，也是本篇笔记的重要来源处。 介绍的数据库： Postgresql、HBase、Redis、MySQL MyBatis 首先在自己项目的创建初期可以在选项中加入MyBatis。也可以在后期的配置pom.xml中加入。 org.springframework.boot spring-boot-starter-web org.mybatis.spring.boot mybatis-spring-boot-starter 2.1.3 mysql mysql-connector-java runtime 以及数据库配置 spring: datasource: # driver-class-name在5.x版本和8.x版本中发生了变化 driver-class-name: com.mysql.cj.jdbc.Driver username: username password: password # 此处默认配置了中文utf-8以及Asia/Shanghai时区 url: jdbc:mysql://localhost:3306/guardianship?characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-13 14:01:19 "},"chapter3/mybatis.html":{"url":"chapter3/mybatis.html","title":"第1节：MyBatis使用","keywords":"","body":"MyBatis使用 此处展示两种MaBatis使用方式，建议在启动类上添加Mapper扫描。 @MapperScan(basePackages = \"com.example.project.mapper\") @SpringBootApplication public class ProjectApplication { public static void main(final String[] args) { SpringApplication.run(ProjectApplication.class, args); } } 注解方式 查看前先上一段我根据前面的写的代码，路径和前面提到的一样。这是一段Mapper的代码： package com.example.project.mapper; import org.apache.ibatis.annotations.Select; import org.springframework.stereotype.Repository; import com.example.project.domain.User; import java.util.List; @Repository public interface UserMapper { @Select(\"SELECT * FROM user WHERE id=#{id}\") List getUserById(int id); } 服务接口： package com.example.project.service; import com.example.project.domain.User; import java.util.List; public interface UserService { List getUserById(int id); } 服务实现： package com.example.project.service.impl; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import com.example.project.domain.User; import com.example.project.mapper.UserMapper; import com.example.project.service.UserService; import java.util.List; @Service @Transactional public class UserServiceImpl implements UserService { @Autowired private UserMapper userMapper; @Override public List getUserById(int id) { return userMapper.getUserById(id); } } XML方式 Mapper代码 package com.example.project.mapper; import org.springframework.stereotype.Repository; import com.example.project.domain.User; import java.util.List; @Repository public interface UserMapper { List getUserById(int id); } mapperXml中防止Mapper的XML文件： SELECT * FROM t_user WHERE id = #{id} 对应的配置 mybatis: mapper-locations: classpath:mapperXml/*.xml 服务接口和服务实现和前面一样。 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-12 16:49:19 "},"chapter3/mybatis_annotation.html":{"url":"chapter3/mybatis_annotation.html","title":"第2节：MyBatis注解","keywords":"","body":"public interface UserMapper2 { @Select(\"select * from user\") List getAllUsers(); @Results({ @Result(property = \"id\", column = \"id\"), @Result(property = \"username\", column = \"u\"), @Result(property = \"address\", column = \"a\") }) @Select(\"select username as u,address as a,id as id from user where id=#{id}\") User getUserById(Long id); @Select(\"select * from user where username like concat('%',#{name},'%')\") List getUsersByName(String name); @Insert({\"insert into user(username,address) values(#{username},#{address})\"}) @SelectKey(statement = \"select last_insert_id()\", keyProperty = \"id\", before = false, resultType = Integer.class) Integer addUser(User user); @Update(\"update user set username=#{username},address=#{address} where id=#{id}\") Integer updateUserById(User user); @Delete(\"delete from user where id=#{id}\") Integer deleteUserById(Integer id); } Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-12 16:42:47 "},"chapter4/":{"url":"chapter4/","title":"第四章","keywords":"","body":"Spring Boot 配置 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-12 00:07:27 "},"appendix/":{"url":"appendix/","title":"附录","keywords":"","body":"Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-10 13:49:00 "},"appendix/annotations.html":{"url":"appendix/annotations.html","title":"注解符","keywords":"","body":"注解 @Bean： @Controller：对象变为Web Controller，是一个MVC类，用来负责处理Web请求，通常和@RequestMapping一起用。 @PathVariable @ResponseBody：此方法返回的是文本而不是视图名称，将直接返回对象到客户端，字符串则直接输出，不是则使用Jackson序列化后输出。 @Repository：声明类为数据库或者其它NoSQL访问类 @RequestMapping：请求路径匹配，被注解的方法被调用，参数path，method。简化后的注解有，@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping。 value，请求的URL 的路径，支持U也模板、正则表达式。 路径匹配：Ant路径表达式，以及用{}匹配路径变量，用${}获得系统值。 method, HTTP 请求方法，有GET 、POST 、PUT 等。 GET，用来获取URL 对应的内容。 POST， 用来向服务器提交信息。 HEAD，同GET ，但不返回消息体，通常用于返回URL 对应的元信息，如过期时间等。搜索引擎通常用HEAD 来获取网页信息。 PUT， 同POST ，用来向服务器提交信息，但语义上更像一个更新操作。同一个数据，多次PUT 操作，也不会导致数据发生改变。而POST 在语义上更类似新增操作。 DELETE，删除对应的资源信息。 PATCH， 类似PUT 方法， 表示信息的局部更新。 consumes，允许的媒体类型（Media Types），如consumes ＝ \"application/ison\"， 对应于请求的HTTP 的Content-Type。 produces，相应的媒体类型，如produces ＝\"application/json\"， 对应于HTTP 的Accept字段。 params， 请求的参数，如params ＝\"action=update\" 。可以判断不存在某个参数或者参在或者参数等于某个固定值。 headers， 请求的HTTP 头的值，如headers ＝ \"myHeader=myValue\"。可以判断不存在某个参数或者参在或者参数等于某个固定值。 @RestController @Controller public class HelloworldController { @RequestMapping(\"/hello\") public @ResponseBody String say(String name) { return \"hello\" +name; } } @Service：声明类为业务处理类，通常和@Transactional一起使用。 @Component：Spring管理类 @Configuration：配置类，通常与注解@Bean配合使用 @Autowired Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-10 23:07:01 "},"appendix/packageversion.html":{"url":"appendix/packageversion.html","title":"包版本查找","keywords":"","body":"Maven包版本查看 访问Maven Search 搜索需要的包名，高级搜索参考Advance Options Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-11 14:28:52 "},"appendix/curl.html":{"url":"appendix/curl.html","title":"CURL使用","keywords":"","body":"CURL -i 返回HTTP头 -H 设置请求头，例如curl URL -H 'Content-Type: application.json' -d 后面添加POST内容，例如curl -XPOST URL -d \"param1=value1&param2=value2\"。 JSON内容可以用引号括起来。例如： curl -XPOST 'example.com/info' -H 'Content-Type:application/json' -d ' { \"name\": \"需要的是啥\", \"type\": \"question\" } ' --data-urlencode 则对POST参数做转义，curl -XPOST --data-urlencode \"param1=value1&param2=需要转义\" -G 发起GET请求 -F 上传文件，用法：curl URL -F \"file=@**.doc\" -F \"name=filename\" 注意点： 通过双引号防止URL转义 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-11 21:54:02 "}}