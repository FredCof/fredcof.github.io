{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 这是我在学习Spring Boot的笔记。欢迎大家和我一起完善。 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 21:36:16 "},"chapter1/":{"url":"chapter1/","title":"第一章","keywords":"","body":"Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-07 21:37:36 "},"chapter1/Spring.html":{"url":"chapter1/Spring.html","title":"第1节：Spring","keywords":"","body":"Spring IoC（控制反转）管理Bean, AOP（面向切面）方式增强Bean功能 Spring IoC容器和AOP IoC Core Container：负责管理对象，通过对象描述对对象初始化以及加强。 例如： @Controller：对象变为Web Controller, 用来负责处理Web请求，@RequestMapping：请求路径匹配，被注解的方法被调用。 @Controller public class HelloworldController { @RequestMapping(\"/sayhello.html\") public @ResponseBody String say(String name) { return \"hello\" +name; } } AOP：通过预编译方式或者运行时刻对目标动态的添加功能。比如要实现用户访问控制，可以对每个Controller 的方法使用一个自定义的注解Function ，用SpringA OP向Controller 每个方法动态地添加用户权限校验功能，类似如下： @RequestMapping(\"/sayhello.html\") public @ResponseBody String say (String name) { return \"hello\" +name ; } @RequestMapping(\"/adduser.html\") @Function(\"user.add\") public @ResponseBody String addUser (String name) { ...... } 此处是个举例，不用理解。 @Configuration // 注解成功引起Sping Container注意 @Aspect // 声明为AOP类 public class RoleAccessConfig { @Around(\"within(@org.springframework.stereotype.Controller * ) && @annotation(function)\") public Object functionAccessCheck(final ProceedingJoinPoint pjp, Function function) throws Throwable { if (function ! =null ) { String functionName = function.value(); if(!canAccess(functionName)) { MethodSignature ms= (MethodSignature) pjp.getSignature(); throw new RuntimeException(\"Can not Acces s\" + ms.getMethod()); } } // 继续处理原有的调用 Object o = pjp.proceed(); return o; } protected boolean canAccess(String functionName) { if(functionName.length()==0) { // 总是允许访问 return true; }else{ // 取出当前用户对应的所有角色，从数据库中查询角色是否有访问functionName的权限 return false; } } } Spring的缺点 使用门槛升高， 要入门Spring 需要较长时间。 对过时技术兼容， 导致使用复杂度升高。 XML 配置已经不是流行的系统配置方式。 集成第三方工具时候，程序员还要考虑工具之间的兼容性。 系统启动慢，不具备热部署功能，完全依赖虚拟机或者We b 服务器的热部 1和4在Spring Boot中被解决 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-10 10:25:18 "},"chapter1/SpringBoot.html":{"url":"chapter1/SpringBoot.html","title":"第2节：Spring Boot","keywords":"","body":"Spring Boot 系统级服务 Spring Boot通过Starter提供系统级服务，下表是Spring Boot提供的Starter： 名称 作用 spring-boot-starter-web Web开发支持， 默认使用Tomcat8 spring-boot-starter-aop AOP 开发支持，使用AspectJ spring-boot-starter-jdbc Spring JDBC spring-boot-starter-data-jpa JPA 方式访问数据库，使用Hibernate 作为JPA 实现 spring-boot-starter-data-elasticsearch 集成Elasticsearch ，默认访问localhost:9200 spring-boot-starter-data-redis 集成Redis ，使用JRedis ，默认连接localhost:6379 spring-boot-starter-cache 缓存， 支持多种缓存方式，如本地的、Redis 、Ehcache 等 spring-boot-devtools 应用程序快速重启的工具，提升开发体验 spring-boot-starter-data-mongodb 集成MongoDB ，默认访问mongodb://localhost/test spring-boot-starter-data-neo4j 集成neo4j ， 默认访问localhost:7474 spring-boot-starter-data-gemfire 集成分布式缓存 spring-boot-starter-data-soIr 基于Apache lucene的搜索平台，默认访问localhost:8983/solr spring-boot-starter-data-cassandra 集成Cassandra，默认访问localhost:7474 spring-boot-stater-data-ldap 集成ldap spring-boot-starter-activemq 消息集成ActiveMQ 支持 spring-boot-starter-amqp 消息集成AMQP 协议支持，如支持RabbitMQ spring-boot-starter-jta-atomikos 分布式事务支持，使用atomikos spring-boot-stater-jta-bitronix 一个开源的分布式事务支持 spring-boot-starter-test 包含JUnit 、Spring Test、Hamcrest 、Mockito 等测试工具 spring-boot-starter-webservices webservice 支持 spring-boot-starter-websocket websocket 支持 spring-boot-starter-jersey REST 应用和Jersey 支持 spring-boot-starter-freemarker Freemaker 支持 优点 实现约定大于配置，是一个低配置的应用系统框架。不像Spring 那样“地狱般的配置体验”， Spring Boot 不需要配置或者极少配置，就能使用Spring 大量的功能。 提供了内置的Tomcat 或者Jetty 容器。 通过依赖的jar 包管理、自动装配技术，容易支持与其他技术体系、工具集成。 支持热加载，开发体验好。也支持Spring Boot 系统监控，方便了解系统运行状况。 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-10 01:27:46 "},"chapter1/HelloWorld.html":{"url":"chapter1/HelloWorld.html","title":"第3节：Hello World","keywords":"","body":"Hello World 教程基于IntelliJ 打开IntelliJ IDEA，选择新建项目 选择Spring Initializer，此处用Default（Spring官网），点击下一步，然后输入Group以及Artifact等，其他的保持不变（可以选择一下Java Version）。 然后编写一个Controller类, 放在Controller目录下面 其中UserController的代码为： package top.cofal.guardianship.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; @RestController @EnableAutoConfiguration public class UserController { @RequestMapping(value = \"/\") public String hello(HttpServletRequest request, HttpServletResponse response) { return \"Hello World!\"; } } 点击右上角的运行，就可以在浏览器的http://localhost:8080/，国内的Maven速度可能很慢，所以建议在运行钱更换国内镜像！ 开启热更新，方便调试，修改pom.xml： org.springframework.boot spring-boot-devtools true org.springframework.boot spring-boot-maven-plugin true 设置IntelliJ 设置中开启自动编译 Ctrl+Shift+Alt+/选择Registry，设置compiler.automake.allow.when.app.running为勾选。 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-10 23:03:45 "},"chapter1/SpringAOP.html":{"url":"chapter1/SpringAOP.html","title":"第4节：Spring AOP","keywords":"","body":"Spring AOP Aspect-Oriented Programming，面向切面编程 应用可以在运行时刻动态地在方法调用前后“织入”一些公共代码，从而提供系统的公共服务。类似Python3中的函数修饰符。 AOP 有如下术语： Aspect：Aspect 声明类似于Java 中的类声明，在Aspect 中会包含一些Pointcut 及相应的Advice。 Joint point ： 表示在程序中明确定义的点，典型的包括方法调用、对类成员的访问， 以及异常处理程序块的执行等。Spring 中的Joint point 只支持方法调用。 Pointcut ： 表示一组Joint point ， 如方法名、参数类型、返回类型等，这些Joint point 通过逻辑关系组合起来， 它定义了相应的Advice 将要发生的地方。简单理解Pointcut（ 一种表达式）一一用来判断在Joint point （方法调用）中执行Advice （操作）。 Advice：Advice 定义了在Pointcut 里面定义的程序点具体要做的操作， 它通过before 、around 、after ( return 、throw 、finally ）来区别是在每个Joint point 之前、之后还是执行前后要调用的代码。 before ： 在执行方法前调用Advice ，比如cache 功能可以在执行方法前先判断是否有缓存。 around ： 在执行方法前后调用Advice ， 这是Spring 框架和应用系统一种最为常用的方法， 参见第一章Spring。 after ： 在执行方法后调用Advice, after return 是方法正常返回后调用， after throw是方法抛出异常后调用。 finally ： 方法调用后执行Advice ， 无论是否抛出异常还是正常返回。 AOP proxy：AOP Proxy 也是Java 对象，由AOP 框架创建， 用来完成上述的动作， AOP对象通常可以通过JDK dyamic proxy 完成，或者使用CGLib 完成。 Weaving ： 实现上述切面编程的代码织入， 可以在编译时刻（通过AspectJ compiler ) ，也可以在运行时刻， Spring 和其他大多数Java 框架都是在运行时刻生成代理。 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-10 14:02:47 "},"chapter2/":{"url":"chapter2/","title":"第二章","keywords":"","body":"Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-10 19:03:33 "},"chapter2/MVC.html":{"url":"chapter2/MVC.html","title":"第1节：MVC","keywords":"","body":"MVC 首先是目录结构： Web 的模板文件位于resources/templates 目录下，模板文件使用的静态资源文件，如JS 、 css 、图片，存放在resources/static 目录下。 @RequestMapping和@Controller 参见附录/注解符 方法参数 @PathVariable，可以将URL 中的值映射到方法参数中。可以是类前和方法先的路径匹配，自动对应同名参数，不同名可以用@PathVariable(\"id\")来对应不同名的参数。 Model，Spring 中通用的MVC 模型，也可以使用Map 和ModelMap 作为渲染视图的模型。 在方法的参数中使用如下： @GetMapping(path = \"/{userid}/get.html\") public String getUser(@PathVariable Long userid, Model model) { User userInfo = userService.getUserById(userid); // model.addAttribute(userinfo) 与下面代码效果相同 // 但是这个方法声明会在之后的代码重构中出现错误，建议使用下面一种 model.addAttribute(\"user\", userinfo); return \"/userinfo.html\"; } 在模板中使用模型中的数据如下： ${user.id}${user.name} Model addAttribute(String attributeName, Object attributeValue)，向模型添加一个变量，attributeName 指明了变量的名称，可以在随后的视图里引用， attributeValue 代表了变量。 Model addAttribute (Object attributeValue)， 向模型添加一个变量，变量的名字就是其类名字首字母小写后转为的Java 变量。 Model addAllAttributes(Map attributes)，添加多个变量，如果变量已经存在，则覆盖。 Model mergeAttributes(Map attributes)，添加多个变量， 如果变量己经存在于模型中，则忽略。 Model addAllAttributes(Collection attributeValues)， 添加多个变量，变量来自于集合的元素， 变量命名规范同时addAttribute(Object attributeValue) 。 boolean containsAttribute(String attributeName)， 判断是否存在变量。 ModelAndView，包含了模型和视图路径的对象。 @GetMapping(path = \"/{ userid}/get2.html\") public ModelAndView getUser2(@PathVariable Long userid, ModelAndView view) { // 也可以如下声明： // public ModelAndView getUser2(@PathVariable Long userid) { // ModelAndView view = new ModelAndView(); User userinfo = userService.getUserById (userid); view.addObject(\"user\",userinfo); view.setViewName(\"/userinfo.html\"); return view; } JavaBean，将HTTP 参数映射到JavaBean 对象。 public String getUser2(@RequestParam(value=\"id\", required=true, defaultValue=\"\") Integer id, String name) 其中复杂的映射如下： 订单名称： 订单明细1： 订单明细2： // 模型代码 public class OrderPostForm { private Order order; private List details; // 忽略getter和setter } // Controller代码 @PostMapping(path=\"./saveorder.json\") @ResponseBody public String saveOrder(OrderPostForm form) { return \"Success\"; } spring.servlet.multipart.enabled=true # 设定上传的文件超过一定长度之后写道零时文件中，0则没有阈值 spring.servlet.multipart.file-size-threshold=0 # 零时文件存放目录，不设定则由Web服务器提供 spring.servlet.multipart.location= # 单个文件的最大尺寸 spring.servlet.multipart.max-file-size=1MB # 单次请求的最大尺寸 spring.servlet.multipart.max-request-size=10MB # 当文件和参数被访问的时候再解析为文件 spring.servlet.multipart.resolve-lazily=false 其中回自动将html中的name属性对应到模型中对应的属性，例如order.name对应order属性的name属性，方括号对应List对应位置的元素。一定要是List不可以是Set。 MultipartFile，用于处理文件上传。 提供的对文件信息获取的方法： getPriginalFilename，获取上传文件的民字； getBytes，获取上传文件内容，转为字节数组； getInputStream，获取一个InputStream； isEmpty，文件上传内容为空，或者没有文件上传； getSize，文件上传的大小； transferTo(File dest)，保存上传文件到目标文件系统； @PostMapping(\"/form\") @ResponseBody public String handleFormUpload(String name, MultipartFile[] files) throws IOException { return \"Success\"; } 对应的html中有多个名为files的文件 选择文件： 选择文件： 选择文件： @ModeIAtribute，使用该注解的变量将作为Model 的一个属性。 @ModelAttribute public void findUserByid(@PathVariable Long id, Model model) { model.addAttribute(\"user\", userService.getUserByid(id)); } // 如果需要注入的属性只有一个等同下面的写法 @ModelAttribute public void findUserByid(@PathVariable Long id) { return userService.getUserByid(id); } @GetMapping(path = \"/{id)/get.json\") @ResponseBody public String getUser(Model model) { System.out.println(model.containsAttribute(\"user\")); return \"success\"; } WebRequest或者NativeWebRequest，类似Servlet Request ，但做了一定封装。 java.io.InputStream 和java.io.Reader，用来获取Servlet API 中的lnputStream/Reader 。 java.io.OutputStream 和java.io.Writer，用来获取Servlet API 中的OutputStream/Writer 。 HttpMethod， 枚举类型， 对应于HTTP Method ，如POST 、GET。 @MatrixVariable，矩阵变量。 @RequestParam， 对应于HTTP 请求的参数，自动转化为参数对应的类型。 @RequestHeader，对应于HTTP 请求头参数，自动转化为对应的类型。 @RequestBody， 自动将请求内容转为指定的对象， 默认使用HttpMessageConverters来转化。同时也说明HTTP的消息体是一个JSON，转化为指定的对象。 @PostMapping(path=\"/savejsonorder.json\") @ResponseBody public String saveOrderByJson(@RequestBody User user) { return user.getName(); } @RequestPart，用于文件上传，对应于HTTP 协议的multipart/form-data 。 @SessionAttribute， 该方法标注的变量来自于Session 的属性。 @RequestAttribute，该标注的变量来自于request 的属性。 @InitBinder，用在方法上，说明这个方法会注册多个转化器，用来个性化地将HTTP请求参数转化成对应的Java 对象，如转化为日期类型、浮点类型、JavaBean 等，当然，也可以实现WebBindinglnitializer 接口来用于Spring Boot 应用所需要的dataBinder 。 @Controller public class MyFormController { @InitBinder protected void initBinder(WebDataBinder binder) { binder.addCustomFormatter(new DateFormatter(\"yyyy-MM-dd\")); } @ResponseBody @RequestMapping(\"/date\") // databind/date?d=2011-1-1 public void printDate(Date d) { System.out.println(d); return; } } BindingResult 和Errors， 用来处理绑定过程中的错误。 Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-11 09:42:09 "},"appendix/":{"url":"appendix/","title":"附录","keywords":"","body":"Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-10 13:49:00 "},"appendix/annotations.html":{"url":"appendix/annotations.html","title":"注解符","keywords":"","body":"注解 @Bean： @Controller：对象变为Web Controller，是一个MVC类，用来负责处理Web请求，通常和@RequestMapping一起用。 @PathVariable @ResponseBody：此方法返回的是文本而不是视图名称，将直接返回对象到客户端，字符串则直接输出，不是则使用Jackson序列化后输出。 @Repository：声明类为数据库或者其它NoSQL访问类 @RequestMapping：请求路径匹配，被注解的方法被调用，参数path，method。简化后的注解有，@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping。 value，请求的URL 的路径，支持U也模板、正则表达式。 路径匹配：Ant路径表达式，以及用{}匹配路径变量，用${}获得系统值。 method, HTTP 请求方法，有GET 、POST 、PUT 等。 GET，用来获取URL 对应的内容。 POST， 用来向服务器提交信息。 HEAD，同GET ，但不返回消息体，通常用于返回URL 对应的元信息，如过期时间等。搜索引擎通常用HEAD 来获取网页信息。 PUT， 同POST ，用来向服务器提交信息，但语义上更像一个更新操作。同一个数据，多次PUT 操作，也不会导致数据发生改变。而POST 在语义上更类似新增操作。 DELETE，删除对应的资源信息。 PATCH， 类似PUT 方法， 表示信息的局部更新。 consumes，允许的媒体类型（Media Types），如consumes ＝ \"application/ison\"， 对应于请求的HTTP 的Content-Type。 produces，相应的媒体类型，如produces ＝\"application/json\"， 对应于HTTP 的Accept字段。 params， 请求的参数，如params ＝\"action=update\" 。可以判断不存在某个参数或者参在或者参数等于某个固定值。 headers， 请求的HTTP 头的值，如headers ＝ \"myHeader=myValue\"。可以判断不存在某个参数或者参在或者参数等于某个固定值。 @RestController @Controller public class HelloworldController { @RequestMapping(\"/hello\") public @ResponseBody String say(String name) { return \"hello\" +name; } } @Service：声明类为业务处理类，通常和@Transactional一起使用。 @Component：Spring管理类 @Configuration：配置类，通常与注解@Bean配合使用 @Autowired Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-10 23:07:01 "},"chapter2/validation.html":{"url":"chapter2/validation.html","title":"第2节：验证框架","keywords":"","body":"Copyright © Cofalconer 2020 all right reserved，powered by Gitbook本书发布时间： 2020-07-11 09:42:55 "}}